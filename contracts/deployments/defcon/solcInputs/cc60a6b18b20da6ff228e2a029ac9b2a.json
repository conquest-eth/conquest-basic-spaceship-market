{
  "language": "Solidity",
  "sources": {
    "src/BasicSpaceshipMarket.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"./outerspace/interfaces/IOuterSpace.sol\";\nimport \"./outerspace/interfaces/IApprovalReceiver.sol\";\n\ncontract BasicSpaceshipMarket is IApprovalReceiver {\n    event SpaceshipsForSale(\n        uint256 indexed location,\n        address indexed owner,\n        uint256 pricePerUnit,\n        uint256 spaceshipsToKeep,\n        uint256 spaceshipsToSell\n    );\n    event SaleCancelled(uint256 indexed location, address indexed owner);\n\n    event SpaceshipsSold(uint256 indexed location, address indexed fleetOwner, uint256 numSpaceships);\n\n    struct SpaceshipSale {\n        uint144 pricePerUnit;\n        uint256 spaceshipsToKeep;\n        uint40 spaceshipsLeftToSell;\n        uint40 timestamp;\n    }\n\n    mapping(uint256 => SpaceshipSale) internal _sales;\n\n    IOuterSpace internal immutable _outerspace;\n\n    constructor(IOuterSpace outerspace) {\n        _outerspace = outerspace;\n    }\n\n    ///@dev useful to get data without any off-chain caching, but does not scale to many locations\n    function getSales(uint256[] calldata locations) external view returns (SpaceshipSale[] memory sales) {\n        sales = new SpaceshipSale[](locations.length);\n        for (uint256 i = 0; i < locations.length; i++) {\n            sales[i] = _sales[locations[i]];\n        }\n    }\n\n    function onApprovalForAllBy(address owner, bytes calldata data) external {\n        require(msg.sender == address(_outerspace), \"APPROVEDBY_EXPECTS_OUTERSPACE\");\n        (uint256 location, uint144 pricePerUnit, uint32 spaceshipsToKeep, uint40 spaceshipsToSell) = abi.decode(\n            data,\n            (uint256, uint144, uint32, uint40)\n        );\n        _setSpaceshipsForSale(owner, location, pricePerUnit, spaceshipsToKeep, spaceshipsToSell);\n    }\n\n    function setSpaceshipsForSale(\n        uint256 location,\n        uint144 pricePerUnit,\n        uint32 spaceshipsToKeep,\n        uint40 spaceshipsToSell\n    ) external {\n        _setSpaceshipsForSale(msg.sender, location, pricePerUnit, spaceshipsToKeep, spaceshipsToSell);\n    }\n\n    function cancelSale(uint256 location) external {\n        address currentOwner = _outerspace.ownerOf(location);\n        require(currentOwner == msg.sender, \"NOT_PLANET_OWNER\");\n        _sales[location].pricePerUnit = 0;\n        _sales[location].spaceshipsToKeep = 0;\n        _sales[location].spaceshipsLeftToSell = 0;\n        _sales[location].timestamp = 0;\n\n        emit SaleCancelled(location, currentOwner);\n    }\n\n    function purchase(\n        uint256 location,\n        uint32 numSpaceships,\n        address payable fleetSender,\n        bytes32 toHash\n    ) external payable {\n        SpaceshipSale memory sale = _sales[location];\n        (, uint40 ownershipStartTime) = _outerspace.ownerAndOwnershipStartTimeOf(location);\n\n        require(sale.timestamp > ownershipStartTime, \"OWNERSHIP_CHANGED_SALE_OUTDATED\");\n\n        // TODO use a min-max and avoid revert this way ?\n        require(sale.spaceshipsLeftToSell > numSpaceships, \"NOT_ENOUGH_ON_SALE\");\n\n        // TODO special case for 0xFFFFF to indicate I want to sell for ever\n        // if (sale.spaceshipsLeftToSell != 2**40-1) {\n        sale.spaceshipsLeftToSell -= numSpaceships;\n        // }\n\n        uint256 toPay = numSpaceships * sale.pricePerUnit;\n        require(msg.value >= toPay, \"NOT_ENOUGH_FUND\");\n        fleetSender.transfer(toPay);\n        if (msg.value > toPay) {\n            payable(msg.sender).transfer(msg.value - toPay);\n        }\n\n        IOuterSpace.FleetLaunch memory launch;\n        launch.fleetSender = fleetSender; // this is checked by outerspace\n        launch.fleetOwner = msg.sender;\n        launch.from = location;\n        launch.quantity = numSpaceships;\n        launch.toHash = toHash;\n        _outerspace.sendFor(launch);\n\n        if (sale.spaceshipsToKeep > 0) {\n            // we can call getPlanetState as the plane state has been updated above\n            IOuterSpace.ExternalPlanet memory planetUpdated = _outerspace.getPlanetState(location);\n\n            // TODO could update OuterSpace.sendFor function to actually specify the amount left, and then pay for that amount if smaller that what wanted\n            require(planetUpdated.numSpaceships >= sale.spaceshipsToKeep, \"TOO_MANY_SPACESHIPS_BOUGHT\");\n        }\n\n        emit SpaceshipsSold(location, msg.sender, numSpaceships);\n    }\n\n    // ----------------------------------------\n    // INTERNAL\n    // ----------------------------------------\n\n    function _setSpaceshipsForSale(\n        address seller,\n        uint256 location,\n        uint144 pricePerUnit,\n        uint32 spaceshipsToKeep,\n        uint40 spaceshipsToSell\n    ) internal {\n        address currentOwner = _outerspace.ownerOf(location);\n        require(currentOwner == seller, \"NOT_PLANET_OWNER\");\n        _sales[location].pricePerUnit = pricePerUnit;\n        _sales[location].spaceshipsToKeep = spaceshipsToKeep;\n        _sales[location].spaceshipsLeftToSell = spaceshipsToSell;\n        _sales[location].timestamp = uint40(block.timestamp);\n\n        emit SpaceshipsForSale(location, currentOwner, pricePerUnit, spaceshipsToKeep, spaceshipsToSell);\n    }\n}\n"
    },
    "src/outerspace/interfaces/IOuterSpace.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.9;\n\nimport \"./IOuterSpaceFleets.sol\";\nimport \"./IOuterSpacePlanets.sol\";\n\n// solhint-disable-next-line no-empty-blocks\ninterface IOuterSpace is IOuterSpaceFleets, IOuterSpacePlanets {}\n"
    },
    "src/outerspace/interfaces/IApprovalReceiver.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.9;\n\ninterface IApprovalReceiver {\n    function onApprovalForAllBy(address owner, bytes calldata data) external;\n}\n"
    },
    "src/outerspace/interfaces/IOuterSpaceFleets.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.9;\n\nimport \"../types/ImportingOuterSpaceTypes.sol\";\nimport \"../events/ImportingOuterSpaceEvents.sol\";\n\ninterface IOuterSpaceFleets is ImportingOuterSpaceTypes, ImportingOuterSpaceEvents {\n\n    function resolveFleet(uint256 fleetId, FleetResolution calldata resolution) external;\n\n    function send(\n        uint256 from,\n        uint32 quantity,\n        bytes32 toHash\n    ) external;\n\n    function sendFor(FleetLaunch calldata launch) external;\n\n    function getFleet(uint256 fleetId, uint256 from)\n        external\n        view\n        returns (\n            address owner,\n            uint40 launchTime,\n            uint32 quantity,\n            uint64 flyingAtLaunch, // can be more than quantity if multiple fleet were launched around the same time from the same planet\n            uint64 destroyedAtLaunch\n        );\n}\n"
    },
    "src/outerspace/interfaces/IOuterSpacePlanets.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.9;\n\nimport \"../types/ImportingOuterSpaceTypes.sol\";\nimport \"../events/ImportingOuterSpaceEvents.sol\";\n\ninterface IOuterSpacePlanets is ImportingOuterSpaceTypes, ImportingOuterSpaceEvents {\n    function setApprovalForAll(address operator, bool approved) external;\n\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    function ownerOf(uint256 location) external view returns (address);\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 location\n    ) external;\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 location,\n        bytes calldata data\n    ) external;\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 location\n    ) external;\n\n    function ownerAndOwnershipStartTimeOf(uint256 location)\n        external\n        view\n        returns (address owner, uint40 ownershipStartTime);\n\n    function getPlanet(uint256 location) external view returns (ExternalPlanet memory state, PlanetStats memory stats);\n\n    function getPlanetState(uint256 location) external view returns (ExternalPlanet memory state);\n\n    function getUpdatedPlanetState(uint256 location) external view returns (ExternalPlanet memory state);\n}\n"
    },
    "src/outerspace/types/ImportingOuterSpaceTypes.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface ImportingOuterSpaceTypes {\n    // front running protection : _frontruunningDelay / 2 slots\n    struct InFlight {\n        uint32 flying;\n        uint32 destroyed;\n        // STORE last attack too, to compute combined attack on it ? uint128 is plainty enough\n    }\n\n    // TODO remove\n    // struct Account {\n    //     // TODO add more info\n    //     // stake for example ? => coild it be used by staking ?\n    //     // numPlanets ?\n    //     // numSpaceships ? => probably too much ?\n    //     uint64 totalProduction;\n    //     uint64 productionDebt;\n    // }\n\n    struct Discovered {\n        uint32 minX;\n        uint32 maxX;\n        uint32 minY;\n        uint32 maxY;\n    }\n\n    // TODO split in 2 structs ? PlanetOwnership and PlanetState ?\n    struct Planet {\n        address owner;\n        uint40 ownershipStartTime; // ~ 34865 years, should be enough :)\n        uint40 exitStartTime; // ~ 34865 years, should be enough :)\n        // TODO uint16 ?\n        ///\n        uint32 numSpaceships; // uint31 + first bit => active // TODO use bool active ?\n        uint40 lastUpdated; // ~ 34865 years, should be enough :)\n        int40 travelingUpkeep; // decrease per _upkeepProductionDecreaseRatePer10000th  * production\n        uint32 overflow;\n        // bool active; // TODO ?\n        // bool exiting; // TODO ?\n    }\n\n    struct Fleet {\n        address owner;\n        uint40 launchTime; // ~ 34865 years, should be enough :)\n        uint32 quantity; // TODO? first bit = done? to keep quantity value on-chain post resolution, actually not needed, can be given in the hash\n        // we got 24bit more to store if needed\n        // operator ? // signer ?\n    }\n\n    struct PlanetStats {\n        int8 subX;\n        int8 subY;\n        uint16 stake;\n        uint16 production;\n        uint16 attack;\n        uint16 defense;\n        uint16 speed;\n        uint16 natives;\n    }\n\n    struct ExternalPlanet {\n        address owner;\n        uint40 ownershipStartTime; // ~ 34865 years, should be enough :)\n        uint40 exitStartTime; // ~ 34865 years, should be enough :)\n        uint32 numSpaceships;\n        uint32 overflow;\n        uint40 lastUpdated; // ~ 34865 years, should be enough :)\n        bool active;\n        // bool exiting;\n        uint256 reward;\n    }\n\n    struct FleetLaunch {\n        address fleetSender;\n        address fleetOwner;\n        uint256 from;\n        uint32 quantity;\n        bytes32 toHash;\n    }\n    struct FleetResolution {\n        uint256 from;\n        uint256 to;\n        uint256 distance;\n        bool gift;\n        address specific;\n        bytes32 secret;\n        address fleetSender; // does not work ?\n        address operator; // should be saved ?\n    }\n}\n"
    },
    "src/outerspace/events/ImportingOuterSpaceEvents.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.9;\n\ninterface ImportingOuterSpaceEvents {\n    event PlanetStake(\n        address indexed acquirer,\n        uint256 indexed location,\n        uint32 numSpaceships,\n        int40 travelingUpkeep,\n        uint32 overflow,\n        uint256 stake\n    );\n    event FleetSent(\n        address indexed fleetSender,\n        address indexed fleetOwner,\n        uint256 indexed from,\n        address operator,\n        uint256 fleet,\n        uint32 quantity,\n        uint32 newNumSpaceships,\n        int40 newTravelingUpkeep,\n        uint32 newOverflow\n    );\n\n    event FleetArrived(\n        uint256 indexed fleet,\n        address indexed fleetOwner,\n        address indexed destinationOwner,\n        uint256 destination,\n        bool gift,\n        uint32 fleetLoss,\n        uint32 planetLoss,\n        uint32 inFlightFleetLoss,\n        uint32 inFlightPlanetLoss,\n        bool won,\n        uint32 newNumspaceships,\n        int40 newTravelingUpkeep,\n        uint32 newOverflow\n    );\n\n    event TravelingUpkeepReductionFromDestruction(\n        uint256 indexed origin,\n        uint256 indexed fleet,\n        uint32 newNumspaceships,\n        int40 newTravelingUpkeep,\n        uint32 newOverflow\n    );\n\n    event PlanetReset(uint256 indexed location);\n\n    event PlanetExit(address indexed owner, uint256 indexed location);\n\n    event ExitComplete(address indexed owner, uint256 indexed location, uint256 stake);\n\n    event RewardSetup(uint256 indexed location, address indexed giver, uint256 rewardId);\n    event RewardToWithdraw(address indexed owner, uint256 indexed location, uint256 indexed rewardId);\n\n    event StakeToWithdraw(address indexed owner, uint256 newStake);\n\n    event Initialized(uint32 minX, uint32 maxX, uint32 minY, uint32 maxY, bytes32 genesis);\n\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    // TODO use it\n    event Transfer(address indexed from, address indexed to, uint256 indexed location);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 999999
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}